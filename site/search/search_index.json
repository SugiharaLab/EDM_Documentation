{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Empirical Dynamic Modeling (EDM) Documentation EDM EDM is a toolkit for analyzing time series of nonlinear dynamical systems, with primary applications of forecasting, causal inference, and more. The algorithms which comprise EDM, developed by George Sugihara, perform state space reconstruction via time delayed embeddings of time series data. An overview of the algorithms provided is provided below and a more in-depth tutorial will be provided further in the documentation. The EDM algorithms are available in Python and R, in the packages pyEDM and rEDM. Foundations of EDM Time Series as Observations of a Dynamic System Why EDM is Necessary for Today's Data Many fields use models as approximations of real world systems (e.g. testing hypotheses regarding mechanisms or processes, explaining past observations, predicting future outcomes). However, real world systems are often complex and high dimensional, making explicit parametric equations impractical. Empirical models, which infer patterns and associations from the data (instead of using hypothesized equations), represent a more natural and flexible approach. Empirical Dynamic Modeling (EDM) provides a framework for predicting and analyzing nonlinear dynamical systems which are typically problematic for traditional modeling approaches. Support General Questions : Our Google Group Bugs / Feature Requests : Github Issues","title":"Home"},{"location":"#empirical-dynamic-modeling-edm-documentation","text":"","title":"Empirical Dynamic Modeling (EDM) Documentation"},{"location":"#edm","text":"EDM is a toolkit for analyzing time series of nonlinear dynamical systems, with primary applications of forecasting, causal inference, and more. The algorithms which comprise EDM, developed by George Sugihara, perform state space reconstruction via time delayed embeddings of time series data. An overview of the algorithms provided is provided below and a more in-depth tutorial will be provided further in the documentation. The EDM algorithms are available in Python and R, in the packages pyEDM and rEDM.","title":"EDM"},{"location":"#foundations-of-edm","text":"","title":"Foundations of EDM"},{"location":"#time-series-as-observations-of-a-dynamic-system","text":"","title":"Time Series as Observations of a Dynamic System"},{"location":"#why-edm-is-necessary-for-todays-data","text":"Many fields use models as approximations of real world systems (e.g. testing hypotheses regarding mechanisms or processes, explaining past observations, predicting future outcomes). However, real world systems are often complex and high dimensional, making explicit parametric equations impractical. Empirical models, which infer patterns and associations from the data (instead of using hypothesized equations), represent a more natural and flexible approach. Empirical Dynamic Modeling (EDM) provides a framework for predicting and analyzing nonlinear dynamical systems which are typically problematic for traditional modeling approaches.","title":"Why EDM is Necessary for Today's Data"},{"location":"#support","text":"General Questions : Our Google Group Bugs / Feature Requests : Github Issues","title":"Support"},{"location":"algorithms_high_level/","text":"Overview of EDM Algorithms Simplex : Nearest Neighbor Projection Simplex SMap : Sequential Locally Weighted Global Linear Maps SMap CCM : Convergent Cross Mapping CCM","title":"Algorithms High Level"},{"location":"algorithms_high_level/#overview-of-edm-algorithms","text":"","title":"Overview of EDM Algorithms"},{"location":"algorithms_high_level/#simplex-nearest-neighbor-projection","text":"Simplex","title":"Simplex : Nearest Neighbor Projection"},{"location":"algorithms_high_level/#smap-sequential-locally-weighted-global-linear-maps","text":"SMap","title":"SMap : Sequential Locally Weighted Global Linear Maps"},{"location":"algorithms_high_level/#ccm-convergent-cross-mapping","text":"CCM","title":"CCM : Convergent Cross Mapping"},{"location":"algorithms_in_depth/","text":"EDM Algorithms In-Depth Simplex : Nearest Neighbor Projection Simplex SMap : Sequential Locally Weighted Global Linear Maps SMap CCM : Convergent Cross Mapping CCM","title":"Algorithms In-Depth"},{"location":"algorithms_in_depth/#edm-algorithms-in-depth","text":"","title":"EDM Algorithms In-Depth"},{"location":"algorithms_in_depth/#simplex-nearest-neighbor-projection","text":"Simplex","title":"Simplex : Nearest Neighbor Projection"},{"location":"algorithms_in_depth/#smap-sequential-locally-weighted-global-linear-maps","text":"SMap","title":"SMap : Sequential Locally Weighted Global Linear Maps"},{"location":"algorithms_in_depth/#ccm-convergent-cross-mapping","text":"CCM","title":"CCM : Convergent Cross Mapping"},{"location":"edm_functions/","text":"Embed Below are brief descriptions of the functions available in the pyEDM and rEDM packages. See general parameters for descriptions of the parameters used in these functions Description : Creates a data block of Takens (1981) time-delay embedding from each of the columns in the csv file or dataFrame. See the Parameters table for parameter definitions. The columns parameter can be a list of column names, or a list of column indices. If columns is a list of indices, then column names are created as V1, V2... Note: The returned DataFrame will have tau * (E-1) fewer rows than the input data from the removal of partial vectors as a result of the embedding. Parameters : pathIn = \"\", dataFile = \"\", dataFrame = None, E = 0, tau = 0, columns = \"\", verbose = False Returns : Constructed DataFrame with embedded columns. Simplex Description : Simplex projection of the input data file or DataFrame. See the Parameters table for parameter definitions. nan values are inserted in the output DataFrame where there is no observation or prediction. If embedded is false the data columns are embedded to dimension E with delay tau . If embedded is true the data columns are assumed to be a multivariable data block. Parameters : pathIn = \"\", dataFile = \"\", dataFrame = None, pathOut = \"\", predictFile = \"\", lib = \"\", pred = \"\", E = 0, Tp = 1, knn = 0, tau = 1, columns = \"\", target = \"\", embedded = False, const_pred = False, verbose = False Returns : Constructed DataFrame with columns \"Time\", \"Observations\", and \"Predictions\". SMap Description : SMap projection of the input data file or DataFrame. See the Parameters table for parameter definitions. nan values are inserted in the output DataFrame where there is no observation or prediction. If embedded is false the data columns are embedded to dimension E with delay tau . If embedded is true the data columns are assumed to be a multivariable data block. If predictFile is provided the predictions will be written to it in csv format. If smapFile is provided the coefficients will be written to it in csv format. If knn is not specified, it is set equal to the library size. If knn is specified, it must be greater than E . Parameters : pathIn = \"\", dataFile = \"\", dataFrame = None, pathOut = \"\", predictFile = \"\", lib = \"\", pred = \"\", E = 0, Tp = 1, knn = 0, tau = 1, theta = 0, exclusionRadius = 0, columns = \"\", target = \"\", smapFile = \"\", embedded = False, const_pred = False, verbose = False Returns : [Dict in pyEDM , named List in rEDM ] with two DataFrames: { predictions - 3 columns : \"Time\", \"Observations\", \"Predictions\"; coefficients - 'E+2' columns : Time, and then 'E+1' SMap SVD fit coefficents. } CCM Description : Convergent cross mapping via Simplex of the first vector specified in columns against target . The data cannot be multivariable, the first vector in columns is time-delay embedded to dimension E . See the Parameters table for parameter definitions. libSizes specifies a string with \"start stop increment\" row values, i.e. \"10 80 10\" will evaluate library sizes from 10 to 80 in increments of 10. If random is true , sample observations are randomly selected from the subset of each library size. If seed=0 , then a random seed is generated for the random number generator. Otherwise, seed is used to initialise the random number generator. If random is false, sample is ignored and contiguous library rows up to the current library size are used. Note: Cross mappings are performed between column : target , and target : column . Parameters : pathIn = \"\", dataFile = \"\", dataFrame = None, pathOut = \"\", predictFile = \"\", E = 0, Tp = 0, knn = 0, tau = 1, columns = \"\", target = \"\", libSizes = \"\", sample = 0, random = True, seed = 0, verbose = False Returns : The returned DataFrame has 3 columns. The first column is LibSize , the second and third columns are Pearson correlation coefficients for column : target and target : column cross mapping. Multiview Description : Multiview embedding and forecasting of the input data file or DataFrame. See the Parameters table for parameter definitions. nan values are inserted where there is no observation or prediction. If predictFile is provided the Predictions will be written to it in csv format. If multiview is not specified it is set to 'sqrt(C)' where C is the number of E -dimensional combinations out of all available data vectors. If knn is not specified, it is set equal to E+1. Parameters : pathIn = \"\", dataFile = \"\", dataFrame = None, pathOut = \"\", predictFile = \"\", lib = \"\", pred = \"\", E = 0, Tp = 1, knn = 0, tau = 1, columns = \"\", target = \"\", multiview = 0, verbose = False, nThreads = 4 Returns : [Dict in pyEDM , named List in rEDM ] with two DataFrames: { Combo_rho, Predictions } The Predictions DataFrame has 3 columns Time , Observations , Predictions . The Combo_rho DataFrame will have E +3 columns. The first E columns are the the column indices in the input data DataFrame that are embedded and applied to Simplex prediction. The last three columns are \"rho\", \"MAE\", \"RMSE\" corresponding to the prediction Pearson correlation, maximum absolute error and root mean square error. EmbedDimension Description : Evaluate Simplex prediction skill for embedding dimensions from 1 to maxE . See the Parameters table for parameter definitions. Note: nThreads defines the number of worker threads for the 10 embeddings. The maximum number of threads is 10. Parameters : pathIn = \"\", dataFile = \"\", dataFrame = None, pathOut = \"\", predictFile = \"\", lib = \"\", maxE = 10, pred = \"\", Tp = 1, tau = 1, columns = \"\", target = \"\", embedded = False, verbose = True, nThreads = 4 Returns : The returned DataFrame has columns E and rho . PredictInterval Description : Evaluate Simplex prediction skill for forecast intervals from 1 to 10. See the Parameters table for parameter definitions. Note: nThreads defines the number of worker threads for the 10 prediction interval forecasts. The maximum number of threads is 10. Parameters : pathIn = \"\", dataFile = \"\", dataFrame = None, pathOut = \"\", predictFile = \"\", lib = \"\", pred = \"\", maxTp = 10, tau = 1, columns = \"\", target = \"\", embedded = False, verbose = True, nThreads = 4 Returns : The returned DataFrame has columns Tp and rho . PredictNonlinear Description : Evaluate SMap prediction skill for localization parameter \u03b8 (default from 0.01 to 9). theta is a string of theta values with a delimiter of [',', '\\t', '\\n']. See the Parameters table for parameter definitions. Parameters : pathIn = \"\", dataFile = \"\", dataFrame = None, pathOut = \"\", predictFile = \"\", lib = \"\", pred = \"\", theta = \"\", E = 0, Tp = 1, tau = 1, columns = \"\", target = \"\", embedded = False, verbose = True, nThreads = 4 Returns : The returned DataFrame has columns theta and rho . ComputeError Description : Compute Pearson correlation coefficient, maximum absolute error (MAE) and root mean square error (RMSE) between two vectors. Parameters : obsIn , predIn Returns : [Dict in pyEDM , named List in rEDM ] with computed rho , RMSE , MAE .","title":"EDM Functions"},{"location":"edm_functions/#embed","text":"Below are brief descriptions of the functions available in the pyEDM and rEDM packages. See general parameters for descriptions of the parameters used in these functions Description : Creates a data block of Takens (1981) time-delay embedding from each of the columns in the csv file or dataFrame. See the Parameters table for parameter definitions. The columns parameter can be a list of column names, or a list of column indices. If columns is a list of indices, then column names are created as V1, V2... Note: The returned DataFrame will have tau * (E-1) fewer rows than the input data from the removal of partial vectors as a result of the embedding. Parameters : pathIn = \"\", dataFile = \"\", dataFrame = None, E = 0, tau = 0, columns = \"\", verbose = False Returns : Constructed DataFrame with embedded columns.","title":" Embed "},{"location":"edm_functions/#simplex","text":"Description : Simplex projection of the input data file or DataFrame. See the Parameters table for parameter definitions. nan values are inserted in the output DataFrame where there is no observation or prediction. If embedded is false the data columns are embedded to dimension E with delay tau . If embedded is true the data columns are assumed to be a multivariable data block. Parameters : pathIn = \"\", dataFile = \"\", dataFrame = None, pathOut = \"\", predictFile = \"\", lib = \"\", pred = \"\", E = 0, Tp = 1, knn = 0, tau = 1, columns = \"\", target = \"\", embedded = False, const_pred = False, verbose = False Returns : Constructed DataFrame with columns \"Time\", \"Observations\", and \"Predictions\".","title":" Simplex "},{"location":"edm_functions/#smap","text":"Description : SMap projection of the input data file or DataFrame. See the Parameters table for parameter definitions. nan values are inserted in the output DataFrame where there is no observation or prediction. If embedded is false the data columns are embedded to dimension E with delay tau . If embedded is true the data columns are assumed to be a multivariable data block. If predictFile is provided the predictions will be written to it in csv format. If smapFile is provided the coefficients will be written to it in csv format. If knn is not specified, it is set equal to the library size. If knn is specified, it must be greater than E . Parameters : pathIn = \"\", dataFile = \"\", dataFrame = None, pathOut = \"\", predictFile = \"\", lib = \"\", pred = \"\", E = 0, Tp = 1, knn = 0, tau = 1, theta = 0, exclusionRadius = 0, columns = \"\", target = \"\", smapFile = \"\", embedded = False, const_pred = False, verbose = False Returns : [Dict in pyEDM , named List in rEDM ] with two DataFrames: { predictions - 3 columns : \"Time\", \"Observations\", \"Predictions\"; coefficients - 'E+2' columns : Time, and then 'E+1' SMap SVD fit coefficents. }","title":" SMap "},{"location":"edm_functions/#ccm","text":"Description : Convergent cross mapping via Simplex of the first vector specified in columns against target . The data cannot be multivariable, the first vector in columns is time-delay embedded to dimension E . See the Parameters table for parameter definitions. libSizes specifies a string with \"start stop increment\" row values, i.e. \"10 80 10\" will evaluate library sizes from 10 to 80 in increments of 10. If random is true , sample observations are randomly selected from the subset of each library size. If seed=0 , then a random seed is generated for the random number generator. Otherwise, seed is used to initialise the random number generator. If random is false, sample is ignored and contiguous library rows up to the current library size are used. Note: Cross mappings are performed between column : target , and target : column . Parameters : pathIn = \"\", dataFile = \"\", dataFrame = None, pathOut = \"\", predictFile = \"\", E = 0, Tp = 0, knn = 0, tau = 1, columns = \"\", target = \"\", libSizes = \"\", sample = 0, random = True, seed = 0, verbose = False Returns : The returned DataFrame has 3 columns. The first column is LibSize , the second and third columns are Pearson correlation coefficients for column : target and target : column cross mapping.","title":" CCM "},{"location":"edm_functions/#multiview","text":"Description : Multiview embedding and forecasting of the input data file or DataFrame. See the Parameters table for parameter definitions. nan values are inserted where there is no observation or prediction. If predictFile is provided the Predictions will be written to it in csv format. If multiview is not specified it is set to 'sqrt(C)' where C is the number of E -dimensional combinations out of all available data vectors. If knn is not specified, it is set equal to E+1. Parameters : pathIn = \"\", dataFile = \"\", dataFrame = None, pathOut = \"\", predictFile = \"\", lib = \"\", pred = \"\", E = 0, Tp = 1, knn = 0, tau = 1, columns = \"\", target = \"\", multiview = 0, verbose = False, nThreads = 4 Returns : [Dict in pyEDM , named List in rEDM ] with two DataFrames: { Combo_rho, Predictions } The Predictions DataFrame has 3 columns Time , Observations , Predictions . The Combo_rho DataFrame will have E +3 columns. The first E columns are the the column indices in the input data DataFrame that are embedded and applied to Simplex prediction. The last three columns are \"rho\", \"MAE\", \"RMSE\" corresponding to the prediction Pearson correlation, maximum absolute error and root mean square error.","title":" Multiview "},{"location":"edm_functions/#embeddimension","text":"Description : Evaluate Simplex prediction skill for embedding dimensions from 1 to maxE . See the Parameters table for parameter definitions. Note: nThreads defines the number of worker threads for the 10 embeddings. The maximum number of threads is 10. Parameters : pathIn = \"\", dataFile = \"\", dataFrame = None, pathOut = \"\", predictFile = \"\", lib = \"\", maxE = 10, pred = \"\", Tp = 1, tau = 1, columns = \"\", target = \"\", embedded = False, verbose = True, nThreads = 4 Returns : The returned DataFrame has columns E and rho .","title":" EmbedDimension "},{"location":"edm_functions/#predictinterval","text":"Description : Evaluate Simplex prediction skill for forecast intervals from 1 to 10. See the Parameters table for parameter definitions. Note: nThreads defines the number of worker threads for the 10 prediction interval forecasts. The maximum number of threads is 10. Parameters : pathIn = \"\", dataFile = \"\", dataFrame = None, pathOut = \"\", predictFile = \"\", lib = \"\", pred = \"\", maxTp = 10, tau = 1, columns = \"\", target = \"\", embedded = False, verbose = True, nThreads = 4 Returns : The returned DataFrame has columns Tp and rho .","title":" PredictInterval "},{"location":"edm_functions/#predictnonlinear","text":"Description : Evaluate SMap prediction skill for localization parameter \u03b8 (default from 0.01 to 9). theta is a string of theta values with a delimiter of [',', '\\t', '\\n']. See the Parameters table for parameter definitions. Parameters : pathIn = \"\", dataFile = \"\", dataFrame = None, pathOut = \"\", predictFile = \"\", lib = \"\", pred = \"\", theta = \"\", E = 0, Tp = 1, tau = 1, columns = \"\", target = \"\", embedded = False, verbose = True, nThreads = 4 Returns : The returned DataFrame has columns theta and rho .","title":" PredictNonlinear "},{"location":"edm_functions/#computeerror","text":"Description : Compute Pearson correlation coefficient, maximum absolute error (MAE) and root mean square error (RMSE) between two vectors. Parameters : obsIn , predIn Returns : [Dict in pyEDM , named List in rEDM ] with computed rho , RMSE , MAE .","title":" ComputeError "},{"location":"edm_intro/","text":"A Beginners Guide to Using EDM EDM is a toolkit for analyzing time series of nonlinear dynamical systems, with primary applications of forecasting, causal inference, and more. High level EDM Workflow : System prediction : Typically we start our analysis with the Simplex function to find the optimal embedding dimension of our data. Conveniently, we can use the EmbedDimension function to automate this trial and error of varying E to find the best rho value. Note the E corresponding to the highest rho value, but prefer a lower embedding dimension if there are close rho values. We typically only use Simplex to find the embedding dimension as it is fast but SMap predicts better for nonlinear systems. Next we will investigate how nonlinear the system is and find the best theta value for SMap. SMap uses the theta value to give points closer to the query point on the system manifold higher weight in our prediction. You can learn more about SMap and how it uses theta here . Use the PredictNonlinear function to determine the theta value with the highest prediction value. If the prediction accuracy increases with theta , the system is identified to have state dependence (nonlinearity) to a degree proportional to theta . You can optionally investigate the prediction decay with the PredictInterval function. Now you can use SMap with your optimally found arguments to perform the system prediction. Use the SMap function to perform the prediction. System analysis : To study the optimal embedding dimension and the degree of nonlinearity of your data, read the System Prediction introduction on using the functions EmbedDimension and PredictNonlinear . To study the causal relationships between two observers of your system, we use the CCM (Convergent Cross Mapping) function. We use CCM rather than correlation analysis to avoid mistaking mirage correlation for causality and for the fact that causation does not necessarily imply correlation . CCM basically evaluates a Granger Causality test for two time series variables to evaluate causality in both directions.","title":"EDM Usage"},{"location":"edm_intro/#a-beginners-guide-to-using-edm","text":"EDM is a toolkit for analyzing time series of nonlinear dynamical systems, with primary applications of forecasting, causal inference, and more.","title":"A Beginners Guide to Using EDM"},{"location":"edm_intro/#high-level-edm-workflow","text":"","title":"High level EDM Workflow :"},{"location":"edm_intro/#system-prediction","text":"Typically we start our analysis with the Simplex function to find the optimal embedding dimension of our data. Conveniently, we can use the EmbedDimension function to automate this trial and error of varying E to find the best rho value. Note the E corresponding to the highest rho value, but prefer a lower embedding dimension if there are close rho values. We typically only use Simplex to find the embedding dimension as it is fast but SMap predicts better for nonlinear systems. Next we will investigate how nonlinear the system is and find the best theta value for SMap. SMap uses the theta value to give points closer to the query point on the system manifold higher weight in our prediction. You can learn more about SMap and how it uses theta here . Use the PredictNonlinear function to determine the theta value with the highest prediction value. If the prediction accuracy increases with theta , the system is identified to have state dependence (nonlinearity) to a degree proportional to theta . You can optionally investigate the prediction decay with the PredictInterval function. Now you can use SMap with your optimally found arguments to perform the system prediction. Use the SMap function to perform the prediction.","title":"System prediction :"},{"location":"edm_intro/#system-analysis","text":"To study the optimal embedding dimension and the degree of nonlinearity of your data, read the System Prediction introduction on using the functions EmbedDimension and PredictNonlinear . To study the causal relationships between two observers of your system, we use the CCM (Convergent Cross Mapping) function. We use CCM rather than correlation analysis to avoid mistaking mirage correlation for causality and for the fact that causation does not necessarily imply correlation . CCM basically evaluates a Granger Causality test for two time series variables to evaluate causality in both directions.","title":"System analysis :"},{"location":"general_parameters/","text":"General Parameters Many of the EDM functions use the same prediction engine, and so they share many of the following parameters. Please refer to the documentation according to the specific function to verify which parameters are applicable as well as the default values (which can change from function to function). Parameter Type Default Purpose pathIn string \"./\" Input data file path dataFile string \"\" Data file name dataFrame pyEDM: Pandas DataFrame, rEDM: data.frame None Input DataFrame pathOut string \"./\" Output file path predictFile string \"\" Prediction output file lib string \"\" [library start index : library stop index] pred string \"\" [prediction start index : prediction stop index] E int 0 Data dimension Tp int 0 Prediction Interval knn int 0 Number nearest neighbors tau int 1 Embedding delay theta int 0 SMap localization exclusionRadius int 0 Prediction vector exclusion radius columns string \"\" Column names or indices for prediction target string \"\" Target library column name or index embedded bool False Is data an embedding const_pred bool False Include non projected forecast data verbose bool False Echo messages smapFile string \"\" SMap coefficient output file libSizes_str string \"\" CCM library sizes sample int 0 CCM number of random samples random bool True CCM use random samples? seed unsigned 0 RNG seed, 0 = random seed","title":"General Parameters"},{"location":"general_parameters/#general-parameters","text":"Many of the EDM functions use the same prediction engine, and so they share many of the following parameters. Please refer to the documentation according to the specific function to verify which parameters are applicable as well as the default values (which can change from function to function). Parameter Type Default Purpose pathIn string \"./\" Input data file path dataFile string \"\" Data file name dataFrame pyEDM: Pandas DataFrame, rEDM: data.frame None Input DataFrame pathOut string \"./\" Output file path predictFile string \"\" Prediction output file lib string \"\" [library start index : library stop index] pred string \"\" [prediction start index : prediction stop index] E int 0 Data dimension Tp int 0 Prediction Interval knn int 0 Number nearest neighbors tau int 1 Embedding delay theta int 0 SMap localization exclusionRadius int 0 Prediction vector exclusion radius columns string \"\" Column names or indices for prediction target string \"\" Target library column name or index embedded bool False Is data an embedding const_pred bool False Include non projected forecast data verbose bool False Echo messages smapFile string \"\" SMap coefficient output file libSizes_str string \"\" CCM library sizes sample int 0 CCM number of random samples random bool True CCM use random samples? seed unsigned 0 RNG seed, 0 = random seed","title":"General Parameters"},{"location":"installation/","text":"Installation Instructions pyEDM pip install pyEDM rEDM install.packages(\"rEDM\") Note for Linux Users We do not provide pyEDM or rEDM binaries for Linux machines. Instead our setup script should build the respective package from scratch. We use a C++ base EDM engine in our packages, so you will need a modern gcc compiler.","title":"Installation"},{"location":"installation/#installation-instructions","text":"","title":"Installation Instructions"},{"location":"installation/#pyedm","text":"pip install pyEDM","title":"pyEDM"},{"location":"installation/#redm","text":"install.packages(\"rEDM\")","title":"rEDM"},{"location":"installation/#note-for-linux-users","text":"We do not provide pyEDM or rEDM binaries for Linux machines. Instead our setup script should build the respective package from scratch. We use a C++ base EDM engine in our packages, so you will need a modern gcc compiler.","title":"Note for Linux Users"}]}